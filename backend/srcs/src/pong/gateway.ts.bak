import {
    WebSocketGateway,
    WebSocketServer,
    SubscribeMessage,
    OnGatewayInit,
    OnGatewayConnection,
    OnGatewayDisconnect,
} from '@nestjs/websockets'
import { IRoute } from 'express';
import {
    Server,
    Socket
} from "socket.io"
import MatchesService from "../matches/matches.service"

export type IQueuePlayer = {
    key: number;
    value: Socket;
}

export interface IMousePos {
    x : number;
    y : number;
}

export enum ErrStatus {
    OK = "ok",
    ERROR = "not ok"
}

export interface IAcknowledgement {
    status : "ok" | "not ok";
}

// export interface IRoomDto {
//     roomId : number;
//     // key : userId, value : their mouse pos
//     players : Map<number, IMousePos>;
//     // TO DO: A game status ?
//     // TO DO: Add flags if needed
//     isFilled : boolean;
//     level? : number;
// }



export enum ServerMessages {
    CREATE_ROOM = "server:createRoom",
    JOIN_ROOM = "server:joinRoom",
    PUSH_GAME = "server:pushGame",
    UPDATE_GAME = "server:updateGame",
    FIND_GAME = "server:findGame",
    CANCEL_FIND = "server:cancelFind",
    UPDATE_MOUSE_POS = "server:updateMousePos",
    CALC_GAME_ST = "server:calcGameSt",
    LEAVE_ROOM = "server:leaveRoom"
}

export enum ClientMessages {
    NOTIFY = "client:notify",
    MATCH_FOUND = "client:matchFound",
    RECEIVE_ST = "client:receiveSt"
}

function toReplaceByEngine(status : any) { return 42; }

@WebSocketGateway()
export class PongGateway implements OnGatewayConnection, OnGatewayDisconnect, OnGatewayInit
{
    @WebSocketServer()
    public server : Server;
    public rooms : Map<number, RoomDto>;
    public matchmakingQueue : IQueuePlayer[];

    constructor(
        private readonly matchesServices : MatchesService
    )
    { }

    afterInit(server : Server)
    { console.log("DEBUG: Server is launched!"); }

    handleConnection(client : Socket)
    { console.log(`DEBUG: New incoming connexion: ${client.id}`); }

    handleDisconnect(client : Socket)
    { console.log(`DEBUG: Disconnextion from: ${client.id}`); }


  /* const [status, setStatus] = useState<IStatusDto>({
    playerOne: {
      x: 0,
      y: (canvasDims.y - PLAYER_HEIGHT) / 2,
      score: 0,
    },
    playerTwo: {
      x: canvasDims.x - PLAYER_WIDTH,
      y: (canvasDims.y - PLAYER_HEIGHT) / 2,
      score: 0,
    },
    ball: defaultBall,
  }); */

    private getRoom(key : number) {
        const room : RoomDto = this.rooms.get(key);

        if (room === undefined)
            throw new Error(); // Room not found
        return room;
    }

    private setRoom(room : RoomDto)
    {
        this.rooms.set(room.id, room);
    }

    @SubscribeMessage(ServerMessages.CREATE_ROOM)
    onCreateRoom(client : Socket, hostId : number) {

        const room : RoomDto = new RoomDto(hostId);
        this.setRoom(room);
        client.join(room.getId());
        client.in(room.getId()).emit(ClientMessages.NOTIFY, `Player with id ${hostId} has joined the room ${room.getId()}`);
    }

    @SubscribeMessage(ServerMessages.JOIN_ROOM)
    onJoinRoom(client : Socket, roomId : number, guestId : number)
    {
        const room : RoomDto = this.getRoom(roomId);
        // TO DO: Can check if the room is filled here or not: THINK ABOUT IT
        if (guestId in room.playerIds)
            throw new Error(); // User is already in the room
        room.addPlayer(guestId);
        this.setRoom(room);
        client.to(room.getId()).emit(ClientMessages.NOTIFY, `Player with id ${guestId} has joined the room ${room.getId()}`);
    }

    @SubscribeMessage(ServerMessages.PUSH_GAME)
    async onPushGame(client : Socket, roomId : number)
    {
        // TO DO: Can check if the room is filled here or not: THINK ABOUT IT

        const room : RoomDto = this.getRoom(roomId);
        
        // TO DO: Can be performed in a smarter way
        for (const playerId of room.playerIds)
            room.setMousePos(playerId, {} as IMousePos);

        this.setRoom(room);

        if (room.playerIds.length < 2)
            throw new Error(); // Unnecesary ... but better check anyways
        await this.matchesServices.createMatch({
            idMatch: room.getId(),
            idPlayerOne: room.playerIds[0].toString(),
            idPlayerTwo: room.playerIds[1].toString(),
            startTime: new Date()
        });
    }

    @SubscribeMessage(ServerMessages.UPDATE_GAME)
    async onUpdateGame(client : Socket, roomId : number)
    {
        const room : RoomDto = this.getRoom(roomId);

        const matchEntity = await this.matchesServices.getCurrentMatchesById(roomId.toString());
        await this.matchesServices.updateMatch(room.getId(), {
            idMatch: room.getId(), // Why is recurent ?
            idPlayerOne: room.playerIds[0].toString(),
            idPlayerTwo: room.playerIds[1].toString(),
            scorePlayerOne: 0, // TO DO: Get the score from somewhere
            scorePlayerTwo: 0, // TO DO: Get the score from somewhere
            startTime: matchEntity.startTime, // Change this
            endTime: new Date()
        });
    }

    @SubscribeMessage(ServerMessages.FIND_GAME)
    onFindGame(client : Socket, playerId : number)
    {
        if (!(playerId in this.matchmakingQueue))
        {
            this.matchmakingQueue.push({
                key: playerId,
                value: client
            });
        }

        if (this.matchmakingQueue.length >= 2)
        {
            const queueLenght : number = this.matchmakingQueue.length;
            const playerOne : IQueuePlayer = this.matchmakingQueue[queueLenght - 2];
            const roomId : number = playerOne.key;
            const playerTwo : IQueuePlayer = this.matchmakingQueue[queueLenght - 1];

            // NOTE: Just for debug
            if (playerOne.key !== playerId && playerTwo.key !== playerId)
                throw new Error();

            this.onCreateRoom(playerOne.value, playerOne.key);
            this.onJoinRoom(playerTwo.value, roomId, playerTwo.key);

            this.matchmakingQueue.splice(queueLenght - 2, 2);

            this.onPushGame(client, roomId);
        }
    }

    @SubscribeMessage(ServerMessages.CANCEL_FIND)
    onCancelFind(client : Socket, playerId : number, callback : (st: IAcknowledgement) => void)
    {
        let status : IAcknowledgement = {status: ErrStatus.OK};
        if (!(playerId in this.matchmakingQueue))
            status = {status: ErrStatus.ERROR};
        this.matchmakingQueue.filter(player => player.key != playerId);
        callback(status);
    }

    @SubscribeMessage(ServerMessages.UPDATE_MOUSE_POS)
    onUpdateMousePos(client : Socket, roomId : number, playerId : number, mousePos : IMousePos)
    {
        const room : RoomDto = this.getRoom(roomId);
        room.setMousePos(playerId, mousePos);
    }

    // TO DO: Init status must be previously held by the room
    // TO DO: Then use it to set the score in update game
    @SubscribeMessage(ServerMessages.CALC_GAME_ST)
    onCalcGameStatus(client : Socket, roomId : number, initStatus : any) // TO DO: Replace by IStatusDto
    {
        const room : RoomDto = this.getRoom(roomId);

        // let mousePos : IMousePos[];
        // for (let i of room.playersMousePos)
        //     mousePos.push(i[1]);

        setInterval(() => {
            //initStatus.playerOne.x = mousePosP1.x;
            initStatus.playerOne.y = room.getMousePos(Number("player1Id")).y;
            //initStatus.playerTwo.x = mousePosP2.x;
            initStatus.playerTwo.y = room.getMousePos(Number("player2Id")).y;
            initStatus = toReplaceByEngine(initStatus);
            this.server.volatile.to(roomId.toString()).emit(ClientMessages.RECEIVE_ST, initStatus);
        }, 25 * 1000); // TO DO: Read doc for times
    }

    @SubscribeMessage(ServerMessages.LEAVE_ROOM)
    onLeaveRoom(client : Socket, roomId : number, playerId : number)
    {
        const room : RoomDto = this.getRoom(roomId);

        client.leave(room.getId());
        room.playerIds.filter(id => id !== playerId);

        client.to(room.getId()).emit(ClientMessages.NOTIFY, `Player with id ${playerId} left the room`);

        if (room.playerIds.length == 0)
            this.rooms.delete(room.id);
    }

    // TO DO: Each room has a game state
    // EACH CLIENT WILL RECEIVE IT TO INIT THEIR GAME
    // PLAYER RECEIVE STATUS BY DEFUALT
    // SPECTATOR RECEIVE STATUS AT RUNNIGN TIME
}
